;;
;;  Copyright (C) 05-01-2012 Jasper den Ouden.
;;
;;  This is free software: you can redistribute it and/or modify
;;  it under the terms of the GNU General Public License as published
;;  by the Free Software Foundation, either version 3 of the License, or
;;  (at your option) any later version.
;;

(defpackage :package-project
  (:use :common-lisp :alexandria :expression-scan :j-string-utils)
  (:export auto-update package-info *src-dir*)
  (:documentation "Packages a project in a simple way."))

(in-package :package-project)

(defun implementation-package-p (pkg)
  "Returns true if package belongs to implementation."
  (eql pkg :common-lisp))

(defvar *package-info* (make-hash-table)
  "Extra info on packages
:system-name for overriding system name. (Like :alexandria.0.dev -> :system-name)
:project-dir default for project directory.(Specifcally given arguments override)
TODO more")

(defun package-info (package &optional what)
  (if what (getf (gethash package *package-info*) what)
           (gethash package *package-info*)))
(defun (setf package-info) (to package what)
  "Note that `what` is not optional."
  (setf (getf (gethash package *package-info*) what) to))

;Some pre-provided ones.(Use init scripts to add yours)
(setf (package-info :alexandria.0.dev :system-name) :alexandria)

(defun update-header (project-dir prepend-file file)
  (let ((header (with-output-to-string (s)
		  (with-open-file (stream (concat project-dir prepend-file))
		    (with-line-by-line stream (line) 
		      (values (write-line line s)))))))
    (ensure-directories-exist "/tmp/cl-package-project/")
    (let ((from-file (concat "/tmp/cl-package-project/" (file-namestring file))))
      (copy-file file from-file)
      (with-open-file (out file :direction :output :if-exists :supersede)
	(write-string header out)
	(with-open-file (in from-file)
	  (with-line-by-line in (line)
	    (unless (and (> (length line) 1) (string= line ";;" :end1 2))
	      (values (write-line line out) t)))
	  (with-line-by-line in (line)
	    (assert (stringp line))
	    (values (write-line line out))))))))

(defun write-system
    (project-dir info
     &key (sys-name (lambda (pkg) (or (package-info pkg :system-name) pkg)))
     src-dir license package 
     (pkg-name (string-downcase (symbol-name package))))
  "Writes .asd file for a project."
  (with-slots ((uses expr-scan::uses) (also-uses expr-scan::also-uses) 
	       (form expr-scan::form) (paths expr-scan::paths)) info
    (with-open-file (stream (concat project-dir pkg-name ".asd")
			    :direction :output :if-does-not-exist :create
			    :if-exists :supersede)
      (format stream 
"~%(defsystem :~a
  :depends-on (~{:~a~^ ~})
  :description ~s~a
  :serial t
  :components ((:module ~s
                 :components (~{(:file \"~a\")~^ ~}))))~%"
	      pkg-name
	      (mapcar (compose #'string-downcase #'symbol-name sys-name)
		      (union
		       (remove package 
			       (remove-if #'implementation-package-p 
					  (append uses also-uses)))
		       (package-info package :extra-dependencies)))
	      (or (cadr (assoc :documentation (cddr form)))
		  "(autogenerated by `manage-systems`)Package docstring apparently\
 missing.")
;Better put a little header on each file about the license too.
	      (if license (format nil "~%    :license \"~a\"" license) "")
	      src-dir
	      (mapcar (lambda (file &key (f (file-namestring file)))
			(subseq f 0 (search ".lisp" f)))
		      (reverse paths))))))

(defun read-empty (stream)
  "Read from the stream until it is dead."
  (do ((list nil (cons (read stream nil :eof) list)))
      ((unless (null list) (eql (car list) :eof)) (reverse (cdr list)))))

(defun auto-update
    (filename &key (subdirs '("doc" "test" "try" "example" "gui")) also)
  "If application under `src/` directory, assume it is a project directory, and\
 update it. `also` allows you to add stuff like autodocumentation. 
package-project-documentation-template autodocs using documentation-template.

TODO handle absolute directories"
  (load filename)
  (let*((fn (tokenize-str filename "" (rcurry #'char= #\/)))
	(p  (position "src" fn :test #'string=)))
    (if-let (module (when p
			(cond ((= p (- (length fn) 2)) "src")
			      ((find (nth (+ p 1) fn) subdirs :test #'string=)
			       (concat "src/" (nth (+ p 1) fn))))))
      (let ((project-dir ;Figure out project directory.
	     (reduce (lambda (have el) (concat have el "/")) (butlast fn 2)
		     :initial-value "/"))
	    (seen-packages (list)))
	(scan filename :*expression-hook* ;Rescan the file.
	      (lambda (expr) 
		(typecase expr ;record seen packages.
		  ((cons (eql defpackage) list)
		   (push (cadr expr) seen-packages)))
		(scan-expression-hook expr)))
	(assert (null(cdr seen-packages)) nil 
		"Only one package per file allowed at the moment.")
      ;Read some info.
	(destructuring-bind (&key info-dir asd-license prepend-file copy-files
				  extra &allow-other-keys)
	    (with-open-file (stream (concat project-dir "package-info"))
	      (remove-if #'null (read-empty stream)))
	  ;Copy some files.
	  (dolist (f copy-files)
	    (let ((to (concat project-dir f)))
	      (ensure-directories-exist to)
	      (copy-file (concat project-dir info-dir f) to)))
	  (dolist (pkg seen-packages) ;Write systems for the packages.
	    (when also ;Do more stuff.
	      (funcall also pkg project-dir extra))
	    (let ((result (access-result 'defpackage pkg)))
	      (write-system project-dir result :src-dir "src" :package pkg
			    :license asd-license)))
	  (when prepend-file ;Add the header if provided.
	    (update-header project-dir 
			   (concat info-dir prepend-file) filename))
	  (list :updated project-dir filename asd-license)))
      (list :didnt-update filename))))
